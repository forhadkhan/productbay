# Development Guide

This document contains detailed information about the project structure, development workflows, and architectural decisions used in ProductBay.


### Setup Instructions

1. **Clone the Repository**
   Navigate to your WordPress plugins directory:
   ```bash
   cd wp-content/plugins
   git clone https://github.com/forhadakhan/productbay.git
   cd productbay
   ```

2. **Install Dependencies**
   Install both JavaScript packages and PHP dependencies:  
   for JS dependencies
   ```bash
   bun install
   ```

   for PHP dependencies
   ```bash
   composer install
   ```

3. **Start Development Server**
   This command checks/starts local Web & DB services, then starts the Bun-powered build process.
   ```bash
   bun run dev
   ```
   *(Automatically uses `dev.ps1` for Windows and `dev.sh` for Linux/macOS)*
   *The React app will hot-reload, and CSS changes will compile instantly.*

4. **Build for Production**
   Before deploying, run the build command to minify and optimize assets.
   ```bash
   bun run build
   ```

5. **Run lints**
   ```bash
   bun run lint
   ```
   or
   ```bash
   bun run lint:php
   ``` 
   or
   ```bash
   bun run lint:css
   ``` 
   etc. 

6. **Build Release Package**
   ```bash
   bun run release
   ```
   for versioned zip
   ```bash
   bun run release -- --versioned
   ``` 

7. **i18n (Translations)**  
   After writing translatable strings, build to extract them:
   
   ```bash
   bun run build
   ```
   Convert `.po` files to JSON for React (requires WP-CLI):
   ```bash
   bun i18n:make-json
   ```
   See [notes/TRANSLATIONS.md](./notes/TRANSLATIONS.md) for complete workflow.

8. **More**  
   Format code:
   ```bash
   bun run format
   ```
   Check Engines:
   ```bash
   bun run check-engines
   ```
   Check Licenses:
   ```bash
   bun run check-licenses
   ```
   

## Project Structure

The project follows a strict separation of concerns, ensuring maintainability and scalability.

```text
productbay/
├── app/                        # PHP Application Logic (The "Brain")
│   ├── Admin/                  # Admin-specific logic (Menu registration, Asset enqueuing)
│   ├── Api/                    # REST API Controllers (Handle React frontend requests)
│   ├── Core/                   # Core infrastructure (Plugin init, DI Container, Router)
│   ├── Data/                   # Data Access Layer (Repositories, Models)
│   ├── Frontend/               # Public-facing logic (Shortcodes, AJAX handlers)
│   └── Http/                   # Request/Response helpers
├── assets/                     # Compiled Public Assets (Generated by build process)
│   ├── css/                    # Compiled Tailwind CSS
│   ├── js/                     # Compiled React & Frontend JS bundles
├── dist/                       # Release Staging Area (Generated by release script)
├── languages/                  # Translation Files (.pot, .po, .mo)
├── node_modules/               # NPM Dependencies (Git ignored)
├── scripts/                    # Build & Maintenance Scripts
├── src/                        # Source Code (The "Face")
│   ├── components/             # Reusable React Components
│   │   ├── ui/                 # Reusable UI Primitives (Buttons, Modals, Inputs)
│   ├── context/                # React Context providers for specialized global state
│   ├── hooks/                  # Custom React hooks for shared logic
│   ├── layouts/                # Admin Layouts (Sidebar, Header wrappers)
│   ├── pages/                  # Main Admin Views (Dashboard, Table Editor, Settings)
│   ├── store/                  # Zustand State Management (Central application state)
│   ├── styles/                 # Raw CSS & Tailwind Directives
│   ├── types/                  # TypeScript Interfaces & Types
│   ├── utils/                  # JS Helper functions & API Clients
│   ├── App.tsx                 # Main React App Entry
│   └── index.tsx               # Entry point mounting the React App to DOM
├── vendor/                     # PHP Dependencies (Composer)
├── .env.example                # Template for environment variables
├── bun.lock                    # Bun lockfile for JS dependencies
├── composer.json               # PHP Dependencies & Scripts
├── composer.lock               # Composer lockfile for PHP dependencies
├── package.json                # JS Dependencies & Scripts
├── phpcs.xml.dist              # PHPCS (PHP Code Sniffer) ruleset for ProductBay
├── productbay.php              # Main Plugin File (Bootstrapper)
├── readme.txt                  # WordPress Plugin Directory Readme
├── tailwind.config.js          # Tailwind CSS Configuration
├── tsconfig.json               # TypeScript Configuration
├── uninstall.php               # Cleanup script executed on plugin deletion
└── webpack.config.js           # Webpack Build Configuration
```

## How It Works

1. **Initialization:** [productbay.php](../productbay.php) bootstraps the [Plugin](../app/Core/Plugin.php) class in `app/Core`.
2. **Admin Load:** The [Admin](../app/Admin/Admin.php) class enqueues `assets/js/admin.js` on the specific plugin page.
3. **React Mount:** [src/index.tsx](../src/index.tsx) finds the `#productbay-root` div and mounts the React App.
4. **Data Fetching:** The React app sends authenticated requests to `app/Api/` endpoints via the WP REST API.
5. **Frontend Rendering:** Using the `[productbay id="123"]` shortcode, the PHP backend renders the initial view, and `assets/js/frontend.js` takes over for interactive elements.


## State Management

We use **Zustand** for global state management in the React admin application. It provides a lightweight, scalable alternative to Redux or React Context.

### Usage
The global store is located at `src/store/useStore.ts`. It follows a standard hook-based pattern:

```typescript
import { useStore } from './store/useStore';

const MyComponent = () => {
    const { count, increment } = useStore();
    return <button onClick={increment}>{count}</button>;
};
```

### Pattern
- **Centralized Store**: Prefer a single, well-organized store in `useStore.ts` for most application data.
- **Slicing (Future)**: If the state grows significantly, we will migrate to a sliced store pattern to maintain readability.
- **Actions**: Define actions (updaters) within the store itself to keep state logic centralized.


## Tailwind CSS Architecture & Best Practices

Uses **Tailwind CSS v4** for styling the React-based admin interface. Since WordPress plugins exist in a shared environment (the WP Admin dashboard), precautions are taken to prevent styles from conflicting with other plugins or the WordPress core UI.

### 1. Scoped Styling (Isolation)

To adhere to WordPress.org best practices regarding CSS conflicts, the project does **not** rely on prefixing every single utility class. Instead, it uses a robust **scoping strategy**:

-   **The Mechanism**: In [tailwind.config.js](../tailwind.config.js), we set `important: '#productbay-root'`.
-   **The Result**: All generated Tailwind utilities are automatically prefixed with an ID selector (e.g., `#productbay-root .text-center`).
-   **Benefit**: This ensures our styles **strictly** apply only to elements inside our React application wrapper (`<div id="productbay-root">`). We can use standard Tailwind classes like `p-4` or `flex` without fear of affecting the global WordPress admin interface.

### 2. Disabling Preflight

Standard Tailwind includes a "Preflight" (reset) set of styles that normalizes HTML elements globally (e.g., removing margins from headers, making images block-level).

-   **Problem**: If included, this global reset would "leak" out of the plugin and break the layout of the WordPress Admin bar, menu, and other pages.
-   **Solution**: Disabled the default preflight in the configuration.
-   **Scoped Reset**: To ensure the app still looks correct, a *scoped* reset is manually added in [src/styles/main.css](../src/styles/main.css) that only targets `#productbay-root`.


### 3. Compliance with WordPress.org Guidelines

This approach is fully compliant with the WordPress Plugin Review Team's guidelines (2024-2025 standards).

-   **Guideline**: "Plugins must prefix all functions, classes, and global variables to avoid conflicts."
-   **CSS Interpretation**: CSS selectors must be unique enough to avoid collisions.
-   **Implementation**: By namespacing all CSS under the unique ID `#productbay-root`, the requirement for uniqueness and conflict prevention is satisfied, essentially "prefixing" every rule at the selector level.

This strategy offers the best of both worlds: a modern, utility-first developer experience and a polite, isolated footprint within the WordPress ecosystem.

## PHP Naming Conventions & Best Practices

To avoid conflicts with other plugins and WordPress core, we adhere to the following strict naming conventions.

### 1. Classes: Use Namespaces (Not Prefixes)
**PSR-4** autoloading standards are followed.
-   **Bad (Old Way)**: `class ProductBay_Admin_Menu { ... }`
-   **Good (Current Way)**: `namespace ProductBay\Admin; class Menu { ... }`

**Why?** Namespaces provide cleaner code, better organization, and improved autoloading support via Composer or our custom SPL autoloader. It naturally isolates our code from the global class scope.

### 2. Global Constants
All global constants **must** be prefixed with `PRODUCTBAY_`.
-   **Example**: `PRODUCTBAY_VERSION`, `PRODUCTBAY_PATH`.

### 3. Global Functions
Avoid global functions whenever possible.
-   If necessary (e.g., for template tags), prefix with `productbay_`.
-   Prefer static methods in namespaced classes: `ProductBay\Utils\Helper::do_something()`.

## Tooling & Linting

Modern tooling is used to ensure code quality.

### Autoloading
**Composer** is used for PSR-4 autoloading.
-   Run `composer install` to verify dependencies.
-   Namespace root: `ProductBay\` -> `app/`.

### Linting Commands
Run these commands to verify your code:
-   **PHP**: `bun run lint:php` (or `composer run-script lint` if defined) - Checks WordPress Coding Standards.
-   **JS/TS**: `bun run lint:js` - Checks eslint rules.
-   **CSS**: `bun run lint:css` - Checks stylelint rules.

### Versioning & Metadata
Always keep metadata consistent across:
1.  `productbay.php` (Plugin Header)
2.  `composer.json`
3.  `package.json`

---

## Internationalization (i18n)

ProductBay supports translations for both PHP and React. See complete documentation:
- **[TRANSLATIONS.md](./TRANSLATIONS.md)** - Full translation workflow and examples


## Lifecycle & Cleanup

ProductBay includes a robust uninstallation process to ensure a clean footprint when deleted.

### Uninstallation Logic

When the plugin is deleted from the WordPress dashboard, `uninstall.php` is triggered to clean up the database.

- **Data Cleanup**: By default, it removes all `productbay_table` custom posts and their associated metadata. It also deletes plugin options like `productbay_settings` and `productbay_onboarding_completed`.
- **Global Variable Prefixing**: To comply with WordPress Coding Standards, all variables in the global scope of `uninstall.php` (such as `$productbay_meta_keys` and `$productbay_meta_key`) are prefixed with `productbay_` to avoid conflicts.
- **Direct Database Cleanup**: It uses direct `$wpdb` queries with proper preparation to ensure legacy meta keys (like `_productbay_config`) are thoroughly removed across the site.

> [!NOTE]
> Users can disable metadata removal during uninstallation via the "Delete data on uninstall" setting in the plugin's General Settings panel.


