# Development Guide

This document contains detailed information about the project structure, development workflows, and architectural decisions used in ProductBay.


### Setup Instructions

1. **Clone the Repository**
   Navigate to your WordPress plugins directory:
   ```bash
   cd wp-content/plugins
   git clone https://github.com/forhadakhan/productbay.git
   cd productbay
   ```

2. **Install Dependencies**
   ```bash
   bun install
   ```

3. **Start Development Server**
   This command starts both the WordPress script watcher and the Bun-powered build process.
   ```bash
   bun start
   ```
   *The React app will hot-reload, and CSS changes will compile instantly.*

4. **Build for Production**
   Before deploying, run the build command to minify and optimize assets.
   ```bash
   bun run build
   ```

5. **Run lints**
   ```bash
   bun run lint
   ```
   or
   ```bash
   bun run lint:php
   ``` 
   or
   ```bash
   bun run lint:css
   ``` 
   etc. 

6. **More**  
   Format code:
   ```bash
   bun run format
   ```
   Plugin Zip:
   ```bash
   bun run plugin-zip
   ``` 
   Check Engines:
   ```bash
   bun run check-engines
   ```
   Check Licenses:
   ```bash
   bun run check-licenses
   ```
   

## ðŸ“‚ Project Structure

The project follows a strict separation of concerns, ensuring maintainability and scalability.

```text
productbay/
â”œâ”€â”€ app/                        # PHP Application Logic (The "Brain")
â”‚   â”œâ”€â”€ Admin/                  # Admin-specific logic (Menu registration, Asset enqueuing)
â”‚   â”œâ”€â”€ Api/                    # REST API Controllers (Handle React frontend requests)
â”‚   â”œâ”€â”€ Core/                   # Core infrastructure (Plugin init, DI Container, Router)
â”‚   â”œâ”€â”€ Data/                   # Data Access Layer (Repositories, Models)
â”‚   â”œâ”€â”€ Frontend/               # Public-facing logic (Shortcodes, AJAX handlers)
â”‚   â”œâ”€â”€ Http/                   # Request/Response helpers
â”‚   â””â”€â”€ Utils/                  # Helper classes and sanitization tools
â”œâ”€â”€ assets/                     # Compiled Public Assets (Generated by build process)
â”‚   â”œâ”€â”€ css/                    # Compiled Tailwind CSS
â”‚   â”œâ”€â”€ js/                     # Compiled React & Frontend JS bundles
â”œâ”€â”€ src/                        # Source Code (The "Face")
â”‚   â”œâ”€â”€ components/             # Reusable React Components
â”‚   â”‚   â”œâ”€â”€ ui/                 # Reusable UI Primitives (Buttons, Modals, Inputs)
â”‚   â”œâ”€â”€ layouts/                # Admin Layouts (Sidebar, Header wrappers)
â”‚   â”œâ”€â”€ pages/                  # Main Admin Views (Dashboard, Table Editor, Settings)
â”‚   â”œâ”€â”€ store/                  # Zustand State Management
â”‚   â”œâ”€â”€ styles/                 # Raw CSS & Tailwind Directives
â”‚   â”œâ”€â”€ types/                  # TypeScript Interfaces & Types
â”‚   â”œâ”€â”€ utils/                  # JS Helper functions & API Clients
â”‚   â”œâ”€â”€ App.tsx                 # Main React App Entry
â”‚   â””â”€â”€ index.tsx               # Entry point mounting the React App to DOM
â”œâ”€â”€ languages/                  # Translation Files (.pot, .po, .mo)
â”œâ”€â”€ node_modules/               # NPM Dependencies (Git ignored)
â”œâ”€â”€ package.json                # JS Dependencies & Scripts
â”œâ”€â”€ productbay.php              # Main Plugin File (Bootstrapper)
â”œâ”€â”€ tsconfig.json               # TypeScript Configuration
â””â”€â”€ webpack.config.js           # Webpack Build Configuration
```

## ðŸ“– How It Works

1. **Initialization:** `productbay.php` bootstraps the `Plugin` class in `app/Core`.
2. **Admin Load:** The `Admin` class enqueues `assets/js/admin.js` on the specific plugin page.
3. **React Mount:** `src/index.tsx` finds the `#productbay-root` div and mounts the React App.
4. **Data Fetching:** The React app sends authenticated requests to `app/Api/` endpoints via the WP REST API.
5. **Frontend Rendering:** Using the `[productbay id="123"]` shortcode, the PHP backend renders the initial view, and `assets/js/frontend.js` takes over for interactive elements.


## ðŸ“¦ State Management

We use **Zustand** for global state management in the React admin application. It provides a lightweight, scalable alternative to Redux or React Context.

### usage
The global store is located at `src/store/useStore.ts`. It follows a standard hook-based pattern:

```typescript
import { useStore } from './store/useStore';

const MyComponent = () => {
    const { count, increment } = useStore();
    return <button onClick={increment}>{count}</button>;
};
```

### Pattern
- **Centralized Store**: Prefer a single, well-organized store in `useStore.ts` for most application data.
- **Slicing (Future)**: If the state grows significantly, we will migrate to a sliced store pattern to maintain readability.
- **Actions**: Define actions (updaters) within the store itself to keep state logic centralized.


## ðŸŽ¨ Tailwind CSS Architecture & Best Practices

Uses **Tailwind CSS v4** for styling the React-based admin interface. Since WordPress plugins exist in a shared environment (the WP Admin dashboard), precautions are taken to prevent styles from conflicting with other plugins or the WordPress core UI.

### 1. Scoped Styling (Isolation)

To adhere to WordPress.org best practices regarding CSS conflicts, the project does **not** rely on prefixing every single utility class. Instead, it uses a robust **scoping strategy**:

-   **The Mechanism**: In `tailwind.config.js`, we set `important: '#productbay-root'`.
-   **The Result**: All generated Tailwind utilities are automatically prefixed with an ID selector (e.g., `#productbay-root .text-center`).
-   **Benefit**: This ensures our styles **strictly** apply only to elements inside our React application wrapper (`<div id="productbay-root">`). We can use standard Tailwind classes like `p-4` or `flex` without fear of affecting the global WordPress admin interface.

### 2. Disabling Preflight

Standard Tailwind includes a "Preflight" (reset) set of styles that normalizes HTML elements globally (e.g., removing margins from headers, making images block-level).

-   **Problem**: If included, this global reset would "leak" out of the plugin and break the layout of the WordPress Admin bar, menu, and other pages.
-   **Solution**: Disabled the default preflight in the configuration.
-   **Scoped Reset**: To ensure the app still looks correct, a *scoped* reset is manually added in `src/styles/main.css` that only targets `#productbay-root`.

```css
/* src/styles/main.css */
@config "../../tailwind.config.js";
@import "tailwindcss/theme";
@import "tailwindcss/utilities";

/* Essential Scoped Preflight */
#productbay-root,
#productbay-root *,
#productbay-root ::before,
#productbay-root ::after {
  box-sizing: border-box;
  border-width: 0;
  border-style: solid;
}
```

### 3. Compliance with WordPress.org Guidelines

This approach is fully compliant with the WordPress Plugin Review Team's guidelines (2024-2025 standards).

-   **Guideline**: "Plugins must prefix all functions, classes, and global variables to avoid conflicts."
-   **CSS Interpretation**: CSS selectors must be unique enough to avoid collisions.
-   **Implementation**: By namespacing all CSS under the unique ID `#productbay-root`, the requirement for uniqueness and conflict prevention is satisfied, essentially "prefixing" every rule at the selector level.

This strategy offers the best of both worlds: a modern, utility-first developer experience and a polite, isolated footprint within the WordPress ecosystem.

## ðŸ˜ PHP Naming Conventions & Best Practices

To avoid conflicts with other plugins and WordPress core, we adhere to the following strict naming conventions.

### 1. Classes: Use Namespaces (Not Prefixes)
**PSR-4** autoloading standards are followed.
-   **Bad (Old Way)**: `class ProductBay_Admin_Menu { ... }`
-   **Good (Current Way)**: `namespace ProductBay\Admin; class Menu { ... }`

**Why?** Namespaces provide cleaner code, better organization, and improved autoloading support via Composer or our custom SPL autoloader. It naturally isolates our code from the global class scope.

### 2. Global Constants
All global constants **must** be prefixed with `PRODUCTBAY_`.
-   **Example**: `PRODUCTBAY_VERSION`, `PRODUCTBAY_PATH`.

### 3. Global Functions
Avoid global functions whenever possible.
-   If necessary (e.g., for template tags), prefix with `productbay_`.
-   Prefer static methods in namespaced classes: `ProductBay\Utils\Helper::do_something()`.

## ðŸ› ï¸ Tooling & Linting

Modern tooling is used to ensure code quality.

### Autoloading
**Composer** is used for PSR-4 autoloading.
-   Run `composer install` to verify dependencies.
-   Namespace root: `ProductBay\` -> `app/`.

### Linting Commands
Run these commands to verify your code:
-   **PHP**: `bun run lint:php` (or `composer run-script lint` if defined) - Checks WordPress Coding Standards.
-   **JS/TS**: `bun run lint:js` - Checks eslint rules.
-   **CSS**: `bun run lint:css` - Checks stylelint rules.

### Versioning & Metadata
Always keep metadata consistent across:
1.  `productbay.php` (Plugin Header)
2.  `composer.json`
3.  `package.json`


