/**
 * Webpack Configuration
 *
 * Extends @wordpress/scripts default config with custom settings:
 * - Custom entry point for admin React app
 * - Custom output directory matching PHP enqueue paths
 * - Path alias for cleaner imports (@/ -> src/)
 *
 * POT extraction is handled by babel.config.js via @wordpress/babel-plugin-makepot
 */
const defaults = require('@wordpress/scripts/config/webpack.config');
const path = require('path');
const webpack = require('webpack');
const fs = require('fs');

// Extract package info for the banner
const packageJson = require('./package.json');
let repoUrl = '';
if (packageJson.repository) {
	repoUrl = typeof packageJson.repository === 'string'
		? packageJson.repository
		: packageJson.repository.url || '';
	repoUrl = repoUrl.replace(/^git\+/, '').replace(/\.git$/, '');
}
const version = packageJson.version || '1.0.0';
const pluginName = 'ProductBay';

const bannerText = `/*!
 * ${pluginName}
 * Copyright (c) ${new Date().getFullYear()} WP Anchor Bay - https://wpanchorbay.com
 *
 * This software is licensed under the GPLv2 or later.
 * This file is generated from un-compiled source code. Do not edit this file directly.
 *
 * Source Code (Root): ${repoUrl}/tree/${version}/
 * Source Code (Admin): ${repoUrl}/tree/${version}/src
 *
 * For license information please see [base].LICENSE.txt
 */`;

// Custom plugin to generate a single .LICENSE.txt file with all production dependencies
// and prepend the banner text to the output files.
class CustomBuildPlugin {
	apply(compiler) {
		compiler.hooks.thisCompilation.tap('CustomBuildPlugin', (compilation) => {
			compilation.hooks.processAssets.tap(
				{
					name: 'CustomBuildPlugin',
					// We use a late stage so it runs after code splitting and minification
					stage: webpack.Compilation.PROCESS_ASSETS_STAGE_REPORT,
				},
				(assets) => {
					const deps = Object.keys(packageJson.dependencies || {});
					let licenseContent = '';

					deps.forEach(dep => {
						try {
							const depPackageJsonPath = path.resolve(__dirname, 'node_modules', dep, 'package.json');
							if (fs.existsSync(depPackageJsonPath)) {
								const depPkg = JSON.parse(fs.readFileSync(depPackageJsonPath, 'utf8'));

								let licenseText = `/**\n * @license ${depPkg.name}\n * version: ${depPkg.version}\n`;
								if (depPkg.author) {
									licenseText += ` * Author: ${typeof depPkg.author === 'string' ? depPkg.author : (depPkg.author.name || 'Unknown')}\n`;
								}
								licenseText += ` * License: ${depPkg.license || 'Unknown'}\n`;

								// Add repository or homepage link instead of full license text
								let url = depPkg.homepage || '';
								if (!url && depPkg.repository) {
									url = typeof depPkg.repository === 'string' ? depPkg.repository : depPkg.repository.url;
								}
								if (url) {
									// Brute force clean commonly weird NPM git URIs
									url = url.replace('git+https://', 'https://')
										.replace('git://', 'https://')
										.replace('.git', '');

									// Handle "user/repo" shorthand or github:user/repo from package.json
									if (!url.startsWith('http') && url.split('/').length === 2 && !url.includes(' ')) {
										url = 'https://github.com/' + url;
									}

									licenseText += ` * URL: ${url}\n`;
								}

								licenseText += ` */\n\n`;
								licenseContent += licenseText;
							}
						} catch (e) {
							console.error(`Failed to extract license for ${dep}`, e);
						}
					});

					// For each emitted JS file, prepend the banner and emit the LICENSE.txt file
					compilation.entrypoints.forEach((entrypoint, name) => {
						const files = entrypoint.getFiles();
						files.forEach(file => {
							if (file.endsWith('.js') && assets[file]) {
								// Prepend Banner
								compilation.updateAsset(
									file,
									new webpack.sources.ConcatSource(bannerText, '\n', assets[file])
								);

								// Emit License File
								compilation.emitAsset(
									`${file}.LICENSE.txt`,
									new webpack.sources.RawSource(licenseContent)
								);
							}
						});
					});
				}
			);
		});
	}
}

// Intercept @wordpress/scripts TerserPlugin to disable extractComments
// so it doesn't create duplicate .LICENSE.txt files or its own header comment.
if (defaults.optimization && defaults.optimization.minimizer) {
	defaults.optimization.minimizer = defaults.optimization.minimizer.map(plugin => {
		if (plugin.constructor.name === 'TerserPlugin') {
			plugin.options.extractComments = false;
			plugin.options.terserOptions = plugin.options.terserOptions || {};
			plugin.options.terserOptions.format = plugin.options.terserOptions.format || {};
			plugin.options.terserOptions.format.comments = /Copyright|license|GPLv2/i;
		}
		return plugin;
	});
}

module.exports = {
	...defaults,

	// 1. Define admin entry point
	entry: {
		admin: './src/index.tsx',
	},

	// 2. Adjust output folder
	output: {
		...defaults.output,
		path: path.resolve(__dirname, 'assets', 'js'),
		filename: '[name].js', // e.g. admin.js
		clean: false, // Don't wipe the assets/js folder for now just in case
	},

	// 3. Setup aliases
	resolve: {
		...defaults.resolve,
		alias: {
			...defaults.resolve.alias,
			'@': path.resolve(__dirname, 'src'),
		},
	},

	// 4. Disable performance hints
	performance: {
		hints: false,
	},

	// 5. Custom Plugins
	plugins: [
		...(defaults.plugins || []),
		new CustomBuildPlugin(),
	],
};
